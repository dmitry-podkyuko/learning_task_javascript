
## Строку в CamelCase
#### Условие:
Создайте метод/функцию так, чтобы она преобразовала слова, разделенные тире/подчеркиванием, в CamelCase.
Первое слово в выходных данных должно быть написано с заглавной буквы, только если исходное слово было написано с заглавной буквы.
Следующие слова всегда должны быть написаны с заглавной буквы.

#### Примеры:
```
'the-stealth-warrior' => 'theStealthWarrior'
'The_Stealth_Warrior' => 'TheStealthWarrior'
'The_Stealth-Warrior' => 'TheStealthWarrior'
```

#### Tests:

```js 
  console.log(myFn('the-stealth-warrior') === 'theStealthWarrior'? 'correct' : 'error' )

```


## Подсчёт очков
#### Условие:
Ваша задача - написать функцию для подсчёта очков при игре в кости.
Игроку всегда будет выдаваться набор из пяти шестигранных кубиков.
Один кубик может быть засчитан только один раз при каждом броске.

Например, выпавшая цифра '5' может быть засчитана либо как часть тройки
(что дает 500 очков), либо как одиночные 50 очков, но не как то и другое в одном броске.

Примечание: ваше решение **не должно изменять входной массив.**

#### Правила подсчёта очков
Выпало | Очки
:-----:|:---------:
 Три 1 | 1000 очков
 Три 6 | 600 очков
 Три 5 | 500 очков
 Три 4 | 400 очков
 Три 3 | 300 очков
 Три 2 | 200 очков
 Одна 1| 100 очков
 Одна 5| 50 очков

#### Пример подсчета очков

Бросок    | Очки
----------|------------------
5 1 3 4 1 | 250: 50 (для 5-ти) + 2 * 100 (для 1-х)
1 1 1 3 1 | 1100: 1000 (для трех единиц) + 100 (для остальных 1)
2 4 4 5 4 | 450: 400 (для трех 4) + 50 (для 5)

## Обновление ассортимента
#### Условие:
Ваша задача - написать функцию, которая принимает в себя два массива и возвращает обновленный список ваших текущих запасов в алфавитном порядке.

Пример
```
currentStock = [[25, 'HTC'], [1000, 'Nokia'], [50, 'Samsung'], [33, 'Sony'], [10, 'Apple']];
newStock = [[5, 'LG'], [10, 'Sony'], [4, 'Samsung'], [5, 'Apple']];

updateInventory(currentStock, newStock) ==> [[15, 'Apple'], [25, 'HTC'], [5, 'LG'], [1000, 'Nokia'], [54, 'Samsung'], [43, 'Sony']];
```

## Интервал IPv4-адресов
#### Условие:
Реализуйте функцию, которая принимает два IPv4-адреса и возвращает количество адресов между ними (включая первый, исключая последний).
Все входные данные будут действительными IPv4-адресами в виде строк.
Последний адрес всегда будет больше первого.

#### Примеры:
* При вводе '10.0.0.0', '10.0.0.50' => возвращает 50
* При вводе '10.0.0.0', '10.0.1.0' => возвращает 256
* При вводе '20.0.0.10', '20.0.1.0' => возвращает 246

```
Решение:
const converter = (ipv4) => ipv4.split('').reduce((acc, octet) => (acc << 8) + parseInt(octet), 0));
const ipsBetween = (start, end) => converter(end) - converter(start);
```

## "Сапёр"
#### Условие:
Вы только что обнаружили квадратное поле (NxN) и заметили предупреждающий знак. 
Знак указывает на то, что в виде двумерной сетки перед вами находится одна мина.

Напишите функцию, которая принимает двумерный массив и возвращает местоположение мины. 
Мина представлена в виде целого числа 1 в двумерном массиве. 
Области в двумерном массиве, которые не являются миной, будут представлены как 0.

Возвращаемое местоположение должно быть массивом, 
где первый элемент - это индекс строки, а второй элемент - индекс столбца местоположения мины. 
Все двумерные массивы, передаваемые в вашу функцию, будут представлять собой квадрат,
и в массиве будет только одна мина.

#### Примеры:
```
[ [1, 0, 0], [0, 0, 0], [0, 0, 0] ] --> [0, 0]
[ [0, 0, 0], [0, 1, 0], [0, 0, 0] ] --> [1, 1]
[ [0, 0, 0], [0, 0, 0], [0, 1, 0] ] --> [2, 1]
```

## Сумма интервалов
#### Условие:
Напишите функцию с именем sumIntervals/sum_intervals,
которая принимает массив интервалов и возвращает сумму всех длин интервалов.
Перекрывающиеся интервалы следует считать только один раз.

Интервалы представлены парой целых чисел в виде массива.
Первое значение интервала всегда будет меньше второго значения. 
Например: [1, 5] - это интервал от 1 до 5. Длина этого интервала равна 4.

Случай, когда интервалы перекрывают друг друга:
[[1, 4], [7, 10], [3, 5]]
Сумма длин этих интервалов равна 7.
Поскольку [1, 4] и [3, 5] перекрываются, мы можем рассматривать интервал как [1, 5], длина которого равна 4.

#### Примеры:
```
sumIntervals([[1, 2], [6, 10], [11, 15]]) => 9
sumIntervals([[1, 4], [7, 10], [3, 5]]) => 7
sumIntervals([[1, 5], [10, 20], [1, 6], [16, 19], [5, 11]]) => 19
sumIntervals([[0, 20], [-100000000, 10], [30, 40]]) => 100000030
```

## Валидация строки
#### Условие:
В данной задаче у вас есть входная строка, и вы должны проверить, является ли она корректным сообщением.
Чтобы принять решение, вам нужно разделить строку на числа, а затем сравнить числа с количеством символов в следующей подстроке.

Например, '3hey5hello2hi' следует разделить на 3, hey, 5, hello, 2, hi и функция должна возвращать значение true, потому что 'hey' состоит из 3 символов, 'hello' - из 5, а 'hi' - из 2; 
Поскольку числа и количество символов совпадают, результатом будет ```true```.

#### Правила:
- Сообщения состоят только из букв и цифр
- Номера могут состоять из нескольких цифр: например, '4code10helloworld' является допустимым сообщением
- Каждое число должно совпадать с номером символа в следующей подстроке. Например, 'hello5' и '2hi2' недопустимы
- Если сообщение представляет собой пустую строку, вы должны вернуть значение ```true```
- Вам нужно придумать максимально оптимальную реализацию. Количество символов в строке может превышать сотни тысяч символов. Идеальное время выполнения <= 1 сек.

#### Пример:
```
'3hey5hello2hi' => true
'' => true
'abc' => false
'2' => false
```


## Сложение массива
#### Условие:
В качестве параметра вы получите массив, содержащий 1 или более целых чисел и число n.

Вот небольшая визуализация процесса:
- Шаг 1: Разделите массив на две части:
```
[1, 2, 5, 7, 2, 3, 5, 7, 8] ==> [1, 2, 5, 7] & [2, 3, 5, 7, 8]
```
- Шаг 2: Поместите массивы "друг на друга":
```
   [1, 2, 5, 7]
[2, 3, 5, 7, 8]
```

- Шаг 3: Сложите их вместе:
```
[2, 4, 7, 12, 15]
```
Повторите описанные выше действия n раз или до тех пор, пока не останется только одно число, а затем верните массив.

#### Пример:
``` 
func([4, 2, 5, 3, 2, 5, 7], 2)

Раунд 1
-------
шаг 1: [4, 2, 5] [3, 2, 5, 7]

шаг 2: [4, 2, 5]
    [3, 2, 5, 7]

шаг 3: [3, 6, 7, 12]

Раунд 2
-------
шаг 1: [3, 6] [7, 12]

шаг 2: [3, 6]
       [7, 12]

шаг 3: [10, 18]

Результат: [10, 18]
```

## Строковый инкремент
#### Условие:
Ваша задача - написать функцию, которая увеличивает значение строки, чтобы создать новую строку.
Если строка уже заканчивается числом, число должно быть увеличено на 1.
Если строка не заканчивается числом. к новой строке следует добавить число 1.

**Внимание:** Если в числе есть начальные нули, то следует учитывать количество цифр.

#### Примеры:
```
foo -> foo1
foo23 -> foo24
foo0042 -> foo0043
foo9 -> foo10
foo099 -> foo100
```

## Найти повторяющиеся слова
#### Условие:
Напишите функцию, которая, получив строку текста (возможно, с пунктуацией и переносами строк), возвращает массив из трех наиболее часто встречающихся слов в порядке убывания количества вхождений.

#### Правила:
- Слово - это последовательность букв (от A до Z), необязательно содержащая один или несколько апострофов (') в формате ASCII.
- Апострофы могут появляться в начале, середине или конце слова ('abc, abc', 'abc', abc).
- Любые другие символы (например, #, \, /, . ...) не являются частью слова и должны рассматриваться как пробелы.
- Совпадения должны быть без учета регистра, а слова в результате должны быть написаны строчными буквами.
- Если текст содержит менее трех уникальных слов, то должны быть возвращены либо 2 первых, либо 1 первое слово, либо пустой массив, если текст не содержит слов.

Примеры:
```
Текст: 'In a village of La Mancha, the name of which I have no desire to call to
mind, there lived not long since one of those gentlemen that keep a lance
in the lance-rack, an old buckler, a lean hack, and a greyhound for
coursing. An olla of rather more beef than mutton, a salad on most
nights, scraps on Saturdays, lentils on Fridays, and a pigeon or so extra
on Sundays, made away with three-quarters of his income.'
Результат: ['a', 'of', 'on']

Текст: 'e e e e DDD ddd DdD: ddd ddd aa aA Aa, bb cc cC e e e'
Результат: ['e', 'ddd', 'aa']

Текст: '  //wont won't won't'
Результат: ['won't', 'wont']
```

## Улучшить последовательность Фибонначи
#### Условие:
Последовательность Фибоначчи традиционно используется для объяснения древовидной рекурсии.
```
function fibonacci(n) {
    if(n==0 || n == 1)
        return n;
    return fibonacci(n-1) + fibonacci(n-2);
}
```
Этот алгоритм хорошо выполняет свою образовательную функцию,
но он чрезвычайно неэффективен из-за того, что мы дважды вызываем функцию Фибоначчи, и правая ветвь рекурсии (т.е. ```fibonacci(n-2)```) пересчитывает все числа Фибоначчи,
уже вычисленные левой ветвью (т.е. ```fibonacci(n-1)```)).

Преобразуйте её в рекурсивную функцию Фибоначчи, которая, используя запоминаемую структуру данных, позволяет избежать недостатков древовидной рекурсии.

## Найти уникальный символ
#### Условие:
Напишите функцию с именем ```first_non_repeating_letter```, которая принимает строковые входные данные и возвращает первый символ, который нигде не повторяется в строке.

В качестве дополнительной проблемы, заглавные и строчные буквы считаются одним и тем же символом, но функция должна возвращать правильный регистр для начальной буквы.

Если строка содержит все повторяющиеся символы, она должна возвращать пустую строку ("");

**Примечание**: по историческим причинам функция называется ```first_non_repeating_letter```, но ваша функция должна обрабатывать любой символ Юникода.

#### Примеры:
```
first_non_repeating_letter('stress') ==> 't';
first_non_repeating_letter('sTreSS') ==> 'T';
first_non_repeating_letter('sTtrReeeeESS') ==> ''
```

## Вытащить домен из URL
#### Условие:
Напишите функцию, которая при вводе URL-адреса возвращает только его доменное имя в виде строки. Например:

#### Примеры:
```
domainExtractor('http://github.com/carbonfive/raygun') ==> 'github'
domainExtractor('http://www.zombie-bites.com') ==> 'zombie-bites'
domainExtractor('https://www.cnet.com') ==> 'cnet'
```

## Форматировать секунды
#### Условие:
Вам нужно написать функцию, которая форматирует длительность в секундах удобным для пользователя способом.

#### Правила:
- Функция должна принимать неотрицательное целое число.
- Если оно равно нулю, она просто возвращает значение "сейчас". В противном случае продолжительность выражается в виде комбинации лет, дней, часов, минут и секунд.
- Для целей этой задачи год всегда равен 365 дням, а сутки - 24 часам.
- Единица измерения времени используется во множественном числе, если число больше 1.
- Компоненты разделяются запятой и пробелом (", "). За исключением последнего компонента, который разделяется 'и'.
- Компонент вообще не появится, если его значение окажется равным нулю. Следовательно, значение '1 минута и 0 секунд' недопустимо, т.к. оно должно оставлять только 1 минуту.
- Единица времени должна использоваться "как можно чаще". Это означает, что функция должна возвращать не 61 секунду, а 1 минуту и 1 секунду вместо этого.

#### Пример:
```
func(62) ==> '1 минута и 2 секунды'.
func(3662) ==> '1 час, 1 минута и 2 секунды'.
```


## В Рим и обратно
#### Условие:
Напишите две функции, которые преобразуют римские цифры в целое число и обратно.
Современные римские цифры записываются путем выражения каждой цифры отдельно,
начиная с самой левой цифры и пропуская любую цифру, значение которой равно нулю. 

#### Правила:
- 1990 год отображается следующим образом: 1000=M, 900=CM, 90=XC; в результате получаем MCMXC
- 2008 год записывается как 2000=MM, 8=VIII; или MMVIII
- В 1666 году используется каждый римский символ в порядке убывания: MDCLXVI.
- Диапазон возможных значений: 1 <= n < 4000
- Число 4 должно быть представлено как IV, а не как IIII.

#### Примеры:
```
В римские:
2000 -> 'MM'
1666 -> 'MDCLXVI'
  86 -> 'LXXXVI'
   1 -> 'I'

Из римских:
'MM'      -> 2000
'MDCLXVI' -> 1666
'LXXXVI'  ->   86
'I'       ->    1
```

#### Подсказка:
| Символ | Число |
:-------:|:------:
|    M   |  1000 |
|   CM   |   900 |
|    D   |   500 |
|   CD   |   400 |
|    C   |   100 |
|   XC   |    90 |
|    L   |    50 |
|   XL   |    40 |
|    X   |    10 |
|   IX   |     9 |
|    V   |     5 |
|   IV   |     4 |
|    I   |     1 |


## Математическое сложение строк
#### Условие:
Учитывая строковые представления двух целых чисел, верните строковое представление суммы этих целых чисел.

#### Правила:
- Строковое представление целого числа не будет содержать никаких символов, кроме цифр из диапазона от "0" до "9".

#### Пример:
```
sumStrings('1', '2') => '3';
```
```
ДЛЯ ПРОВЕРЯЮЩЕГО:
Особенность - код должен уметь работать с огромными числами.
Например, sumStrings('712569312664357328695151392', '8100824045303269669937')
должно вывести не '7.125774134884027e+26', а '712577413488402631964821329'
```

## Пекарня
#### Условие:
Напишите функцию cakes(), которая принимает рецепт и доступные ингредиенты и возвращает максимальное количество тортов, которые возможно будет испечь.

#### Пример:
```
cakes(
    {flour: 500, sugar: 200, eggs: 1}, 
    {flour: 1200, sugar: 1200, eggs: 5, milk: 200}
) ==> 2
cakes(
    {apples: 3, flour: 300, sugar: 150, milk: 100, oil: 100}, 
    {sugar: 500, flour: 2000, milk: 2000}
) ==> 0 
```

## Валидация пароля
#### Условие:
Вам нужно написать регулярное выражение, которое будет проверять пароль.

#### Критерии:
- Длина не менее шести символов
- Cодержит строчную букву
- Cодержит заглавную букву
- Содержит цифру
- Содержит только буквенно-цифровые символы (обратите внимание, что "_" не является буквенно-цифровым)

## Парсинг химической формулы
#### Условие:
Для заданной химической формулы, представленной строкой, подсчитайте количество атомов каждого элемента, содержащегося в молекуле, и верните объект.

#### Правила:
- Некоторые формулы заключены в квадратные скобки. Индекс за скобками указывает на то, что вам нужно умножить количество атомов внутри скобки на этот индекс.
- Скобки могут быть круглыми, квадратными или фигурными, а также могут быть вложенными.

#### Примеры:
```
const water = 'H2O';
parse Molecule(water) ==> {H: 2, O: 1};

const magnesiumHydroxide = 'Mg(OH)2';
parseMolecule(magnesiumHydroxide) ==> {Mg: 1, O: 2, H: 2};

const fremySalt = 'K4[ON(SO3)2]2';
parseMolecule(fremySalt) ==> {K: 4, O: 14, N: 2, S: 4};
```

## Нули - в конец!
#### Условие:
Напишите алгоритм, который берет массив и перемещает все нули в конец, сохраняя порядок расположения остальных элементов.

#### Пример:
```
moveZeros([false,1,0,1,2,0,1,3,'a']) ==> [false,1,1,2,1,3,'a',0,0]
```

## Поросячья латынь
#### Условие:
Перенесите первую букву каждого слова в конец, затем добавьте 'ay' в конце слова. Знаки препинания оставьте без изменений.

#### Пример:
```
pigIt('Pig latin is cool'); ==> igPay atinlay siay oolcay
pigIt('Hello world !'); ==> elloHay orldway !
```

## Секунды в ЧЧ:ММ:СС
#### Условие:
Напишите функцию, которая принимает неотрицательное целое число (секунды) в качестве входных данных и возвращает время в удобочитаемом формате (ЧЧ:ММ:СС).

#### Правила:
- ЧЧ = часы, диапазон: 00 - 99
- ММ = минуты, диапазон: 00 - 59
- СС = секунды, диапазон: 00 - 59
- Максимальное время никогда не превышает 359999 (99:59:59)

## RGB в Hex
#### Условие:
Создайте функцию, которая будет в ответ на десятичные аргументы RGB возвращать шестнадцатеричное представление.

#### Правила:
- Допустимые десятичные значения для RGB - от 0 до 255.
- Любые значения, выходящие за пределы этого диапазона, должны быть округлены до ближайшего допустимого значения.
- Ваш ответ всегда должен состоять из 6 символов, сокращение до 3 здесь не подойдет.

#### Пример:
```
255, 255, 255 --> 'FFFFFF'
255, 255, 300 --> 'FFFFFF'
0, 0, 0       --> '000000'
148, 0, 211   --> '9400D3'
```

## Генератор хештегов
#### Условие:
Создайте функцию, которая принимает строку и возвращает хэштег с её использованием.

#### Правила:
- Итоговая строка должна начинаться с хэштега (#).
- Первая буква во всех словах должна быть заглавной.
- Если конечный результат длиннее 140 символов, он должен возвращать значение false.
- Если входные данные или результат являются пустой строкой, он должен возвращать значение false.

#### Пример:
```
' Hello there thanks for trying my Kata'  =>  '#HelloThereThanksForTryingMyKata'
'    Hello     World   '                  =>  '#HelloWorld'
''                                        =>  false
```

## Максимальная сумма подмассивов
#### Условие:
Создайте функцию, которая принимает массив и находит максимальную сумму непрерывной подпоследовательности чисел.

#### Правила:
- Если в массиве нет отрицательных чисел, то нужно вернуть сумму всех элементов.
- Если в массиве нет положительных чисел, то нужно вернуть 0.

#### Пример:
```
maxSequence([-2, 1, -3, 4, -1, 2, 1, -5, 4]) ==> 6 ([4, -1, 2, 1]);
maxSequence([]) ==> 0;
```

## Перемешки
#### Условие:
Создайте функцию, которая возвращает значение ```true```, если часть символов str1 можно переставить так, чтобы получилась str2, в противном случае возвращает значение ```false```.

#### Правила:
- Будут использоваться только строчные буквы (a-z). Знаки препинания и цифры не будут включены.

#### Пример:
```
scramble('rkqodlw', 'world') ==> true
scramble('cedewaraaossoqqyt', 'codewars') ==> true
scramble('katas', 'steak') ==> false
```

## Количество конечных нулей из N!
#### Условие:
Напишите функцию, которая вычислит количество конечных нулей в факториале заданного числа.

N! = 1 * 2 * 3 * ... * N

#### Правила:
- Функция не подразумевает подсчёт факториала. Вам нужно найти другой способ.

#### Пример:
```
countZeros(6) ==> 1 (720)
countZeros(12) ==> 2 (479001600)
```

## Помощник для пагинации
#### Условие:
Вы создадите класс PaginationHelper, который является служебным классом, используемым для запроса информации о подкачке, связанной с массивом.

#### Правила:
- Типы значений, содержащихся в коллекции/массиве, не имеют значения.

#### Пример:
```
сonst helper = new PaginationHelper(['a','b','c','d','e','f'], 4);
helper.pageCount() ==> 2;
helper.itemCount() ==> 6;
helper.pageItemCount(0) ==> 4;
helper.pageItemCount(1) ==> 2;
helper.pageItemCount(2) ==> -1 т.к. страницы не существует;

// pageIndex принимает индекс сущности и возвращает страницу, на которой она находится;
helper.pageIndex(5) ==> 1;
helper.pageIndex(2) ==> 0;
helper.pageIndex(20) ==> -1;
helper.pageIndex(-10) ==> -1;
```

## ROT13
#### Условие:
Написать функцию шифрования/дешифрования строкового сообщения.

#### Правила:
- Знаки препинания и числа не должны изменяться в ходе операций.

#### Подсказка:
```
'abcdefghijklmnopqrstuvwxyz'
```

#### Пример:
```
'EBG13 rknzcyr.' ==> 'ROT13 example.';
'This is my first ROT13 excercise!' ==> 'Guvf vf zl svefg EBG13 rkprepvfr!';
```

## Hex в RGB
#### Условие:
Создать функцию, принимающую в себя Hex и возвращающую RGB.

#### Правила:
- Функция принимает в качестве параметра шестнадцатеричную цветовую строку без учета регистра (например, '#FF9933' или '#ff9933')
- Возвращает Map<String, int> со структурой {r: 255, g: 153, b: 51}, где значения r, g и b варьируются от 0 до 255
- Вы не должны учитывать сокращённую нотацию ('#FFF')

#### Пример:
```
'#FF9933' --> {r: 255, g: 153, b: 51}
```

## Найти уникальную строку
#### Условие:
Создать функцию, принимающую в себя массив строк и возвращающую единственную уникальную.

#### Правила:
- Строки могут содержать пробелы, они в поиске не учитываются.
- Гарантируется, что массив содержит более 2 строк.

#### Пример:
```
findUniq([ 'Aa', 'aaa', 'aaaaa', 'BbBb', 'Aaaa', 'AaAaAa', 'a' ]) ==> 'BbBb';
findUniq([ 'abc', 'acb', 'bac', 'foo', 'bca', 'cab', 'cba' ]) ==> 'foo';
```

## Кастомный flat()
#### Условие:
Создать функцию. кастомно реализующую Array.prototype.flat().

#### Пример:
```
const arr = [1, [2], [3, [4]]];

flat(arr) ==> [1, 2, 3, [4]];
flat(arr, 1) ==> [1, 2, 3, [4]];
flat(arr, 2) ==> [1, 2, 3, 4];
```

## Развернуть строку
#### Условие:
Напишите функцию, которая принимает строку и возвращает её в обратном порядке.

#### Правила:
- Использование reverse() запрещено.
- Решение должно работать для Unicode-символов.

#### Пример:
```
reverseString('hello') ==> 'olleh';
reverseString('12345') ==> '54321';
reverseString('🔥JS🔥') ==> '🔥SJ🔥';
```

## Проверка палиндрома
#### Условие:
Напишите функцию, которая проверяет, является ли строка палиндромом (читается одинаково в обоих направлениях).

#### Правила:
- Игнорировать регистр и пробелы.
- Использование reverse() запрещено.

#### Пример:
```
isPalindrome('racecar') ==> true;
isPalindrome('Level') ==> true;
isPalindrome('hello') ==> false;
isPalindrome('A man a plan a canal Panama') ==> true;
```

## Фильтр уникальных значений массива
#### Условие:
Напишите функцию, которая принимает массив и возвращает новый массив только с уникальными значениями.

#### Правила:
- Нельзя использовать Set и Map.
- Решение должно учитывать примитивные типы данных.

#### Пример:
```
uniqueArray([1, 2, 2, 3, 4, 4, 5]) ==> [1, 2, 3, 4, 5];
uniqueArray(['a', 'b', 'a', 'c']) ==> ['a', 'b', 'c'];
uniqueArray([true, false, true]) ==> [true, false];
```

## Чаще всего встречающийся элемент в массиве
#### Условие:
Напишите функцию, которая находит элемент, встречающийся в массиве чаще всего.

#### Правила:
- В случае нескольких элементов с одинаковой частотой — вернуть любой из них.

#### Пример:
```
mostFrequent([1, 2, 2, 3, 3, 3, 4]) ==> 3;
mostFrequent(['apple', 'banana', 'apple', 'orange']) ==> 'apple';
```

## Группировка слов по длине
#### Условие:
Напишите функцию, которая принимает массив слов и группирует их по длине.

#### Правила:
- Ключи в объекте должны быть числами (длина слова).

#### Пример:
```
groupWordsByLength(["hi", "hello", "bye", "world"]) ==> { 2: ["hi"], 5: ["hello", "world"], 3: ["bye"] };
```

## Группировка слов по длине
#### Условие:
Напишите функцию, которая удаляет повторяющиеся слова в строке.

#### Пример:
```
removeDuplicateWords("This is a test test string") ==> "This is a test string";
removeDuplicateWords("hello hello world") ==> "hello world";
```

## Сортировка по количеству букв "a"
#### Условие:
Отсортируйте массив строк по количеству букв "a" в слове.

#### Пример:
```
sortByA(["banana", "apple", "grape"]) ==> ["banana", "apple", "grape"];
sortByA(["aaa", "a", "aa"]) ==> ["a", "aa", "aaa"];
```

#### Усложнение:
Функция принимает вторым аргументом букву, по которой будет идти сортировка.

## Проверка баланса скобок
#### Условие:
Напишите функцию, которая проверяет, правильно ли расставлены скобки в строке.

#### Пример:
```
isBalanced('()') ==> true;
isBalanced('(()') ==> false;
isBalanced('(())') ==> true;
isBalanced('({[]})') ==> true;
isBalanced('({[)]}') ==> false;
```

## Проверка баланса скобок
#### Условие:
Напишите функцию, которая случайным образом перемешивает массив.

#### Пример:
```
shuffle([1, 2, 3, 4, 5]) ==> [3, 1, 5, 2, 4];
shuffle([1, 2, 3, 4, 5]) ==> [5, 3, 1, 4, 2];
```

## Уникальные элементы в двух массивах
#### Условие:
Напишите функцию, которая возвращает уникальные элементы из двух массивов.

#### Пример:
```
uniqueFromTwoArrays([1, 2, 3], [3, 4, 5]) ==> [1, 2, 4, 5];
```

## Фибоначчи через асинхронность
#### Условие:
Напишите функцию, которая возвращает n-й член последовательности Фибоначчи с использованием ```async/await```.

#### Пример:
```
fibonacciAsync(10).then(console.log) ==> 55;
```

## Удаление ложных значений из массива
#### Условие:
Функция должна удалять false, null, 0, "", undefined, NaN.

#### Пример:
```
clearFalsy([0, 1, false, 2, "", 3, NaN, undefined]) ==> [1, 2, 3];
```

## Разделение массива на группы
#### Условие:
Разбить массив на подмассивы заданного размера.

#### Пример:
```
chunkArray([1, 2, 3, 4, 5, 6], 2) ==> [[1, 2], [3, 4], [5, 6]];
```

## Найти пропущенное число
#### Условие:
Напишите функцию, которая находит пропущенное число в массиве от 1 до n.

#### Пример:
```
findLostNumber([1, 2, 4, 5]) ==> 3;
findLostNumber([3, 7, 1, 2, 8, 4, 5]) ==> 6;
```

## Найти второй максимум
#### Условие:
Напишите функцию, которая находит второй по величине элемент в массиве чисел.

#### Пример:
```
findSecondMax([1, 3, 5, 2, 4]) ==> 4;
findSecondMax([10, 20, 30, 40]) ==> 30;
```

## Конкатенация уникальных символов
#### Условие:
Напишите функцию, которая принимает массив строк и возвращает строку, состоящую только из уникальных символов всех строк.

#### Пример:
```
concatUnique(['hello', 'world']) ==> 'helowrd';
concatUnique(['abc', 'def', 'a']) ==> 'abcdef';
```

## Замена undefined на null
#### Условие:
Напишите функцию, которая возвращает копию, в которой все undefined заменены на null.

#### Пример:
```
undefinedToNull({a: undefined, b: 'BFE.dev'}) ==> {a: null, b: 'BFE.dev'};
undefinedToNull({a: ['BFE.dev', undefined, 'bigfrontend.dev']}) ==> {a: ['BFE.dev', null, 'bigfrontend.dev']};
```

## Добавить точки к числам
#### Условие:
Напишите функцию, которая добавить запятые к введённому числу в качестве разделителей тысяч.

#### Правила:
- Число после точек - вещественная часть, в ней никаких разделителей быть не должно.

#### Пример:
```
addComma(1) ==> '1';
addComma(1000) ==> '1,000';
addComma(-12345678) ==> '-12,345,678';
addComma(12345678.12345) ==> '12,345,678.12345';
```

## Кратные 3 или 5
#### Условие:
Напишите функцию, которая будет находить сумму всех значений, кратных 3 или 5, ниже переданного числа.

#### Правила:
- Если число отрицательное, верните 0.
- Если число кратно как 3, так и 5, подсчитайте его только один раз.

#### Пример:
```
solution(10) ==> 23;
```

## Выборочный реверс
#### Условие:
Напишите функцию, которая принимает строку из одного или нескольких слов и возвращает ту же строку, но все слова, в которых пять или более букв, перевернуты.

#### Правила:
- Передаваемые строки будут состоять только из букв и пробелов.
- Пробелы будут включены только в том случае, если присутствует более одного слова.

#### Пример:
```
spinWords('Hey fellow warriors') ==> 'Hey wollef sroirraw' 
spinWords('This is a test') ==> 'This is a test'
spinWords('This is another test') ==> 'This is rehtona test'
```

## Кому это нравится? 
#### Условие:
Реализуйте функцию, которая принимает массив, содержащий имена людей, которым понравился товар.

#### Правила:
- Для 4 или более имен число в графе "and 2 others" просто увеличивается.

#### Пример:
```
likes([]) ==> "no one likes this";
likes(["Peter"]) ==> "Peter likes this";
likes(["Jacob", "Alex"]) ==> "Jacob and Alex like this";
likes(["Max", "John", "Mark"]) ==> "Max, John and Mark like this";
likes(["Alex", "Jacob", "Mark", "Max"]) ==> "Alex, Jacob and 2 others like this";
```

## Странное число
#### Условие:
Реализуйте функцию, которая находит в массиве целых чисел то, которое встречается нечетное количество раз.

#### Правила:
- Всегда будет только одно целое число, которое встречается нечетное число раз.

#### Пример:
```
findOdd([7]) ==> 7;
findOdd([0]) ==> 0;
findOdd([1,1,2]) ==> 2;
findOdd([0,1,0,1,0]) ==> 0;
findOdd([1,2,2,3,3,3,4,3,3,3,2,2,1]) ==> 4;
```

## Создайте телефонный номер
#### Условие:
Напишите функцию, которая принимает массив из 10 целых чисел (от 0 до 9) и возвращает строку из этих чисел в виде телефонного номера.

#### Пример:
```
createPhoneNumber([1, 2, 3, 4, 5, 6, 7, 8, 9, 0]) ==> '(123) 456-7890';
```

## Счётчик битов
#### Условие:
Напишите функцию, которая принимает целое число в качестве входных данных и возвращает количество битов, равных 1 в двоичном представлении этого числа. 

#### Правила:
- Входные данные всегда неотрицательны.

#### Пример:
```
bitCounter(1234) ==> 5 (10011010010);
```

## Шифровка дубликатов
#### Условие:
Напишите функцию, которая принимает строку и возвращает конвертированную где каждый символ в новой строке равен "(", если этот символ встречается в исходной строке только один раз, или ")", если этот символ встречается в исходной строке более одного раза.

#### Правила:
- Заглавные буквы = строчным буквам, т.е. являются дубликатами друг друга.

#### Пример:
```
encode('din') ==> '(((';
encode('recede') ==> '()()()';
encode('Success') ==> ')())())';
encode('(( @')  ==>  '))((';
```

## Буквы на позицию
#### Условие:
Напишите функцию, которая принимает строку и заменяет все буквы на их позицию в алфавите.

#### Правила:
- Все символы, не являющиеся буквами, должны быть проигнорированы и возвращены без изменений.

#### Пример:
```
alphabetPosition("The sunset sets at twelve o' clock.") ==> "20 8 5 19 21 14 19 5 20 19 5 20 19 1 20 20 23 5 12 22 5 15 3 12 15 3 11";
```

## Подсчет дубликатов
#### Условие:
Напишите функцию, которая будет возвращать количество различных буквенных символов без учета регистра и цифровых цифр, которые встречаются в переданной строке более одного раза.

#### Правила:
- Строка может содержать буквы алфавита (строчные и прописные) и цифры.

#### Пример:
```
duplicateCount("abcde") ==> 0;
duplicateCount("aabbcde") ==> 2;
duplicateCount("aabBcde") ==> 2;
duplicateCount("indivisibility") ==> 1;
duplicateCount("Indivisibilities") ==> 2;
duplicateCount("aA11") ==> 2;
duplicateCount("ABBA") ==> 2;
```

## Улитка
#### Условие:
Напишите функцию, которая принимает в себя массив (NxN) и возвращает элементы в порядке от крайних к центральному, направляясь по часовой стрелке.

#### Правила:
- Идея не в том, чтобы сортировать элементы от наименьшего значения к наибольшему; идея в том, чтобы перемещаться по двумерному массиву по часовой стрелке в виде улитки.
- 0x0 (пустая матрица) представляется в виде пустого массива внутри массива [[]].

#### Пример:
```
array = [[1,2,3],
         [4,5,6],
         [7,8,9]];
snail(array) ==> [1,2,3,6,9,8,7,4,5];

Для лучшего понимания:
array = [[1,2,3],
         [8,9,4],
         [7,6,5]];
snail(array) ==> [1,2,3,4,5,6,7,8,9]
```

## Башня
#### Условие:
Напишите функцию, которая строит башню в форме пирамиды в виде массива/списка строк с заданным целым положительным числом этажей. Блок башни обозначается символом "*".

#### Правила:
- Идея не в том, чтобы сортировать элементы от наименьшего значения к наибольшему; идея в том, чтобы перемещаться по двумерному массиву по часовой стрелке в виде улитки.
- 0x0 (пустая матрица) представляется в виде пустого массива внутри массива [[]].

#### Пример:
```
tower(3) ==> [
  "  *  ",
  " *** ", 
  "*****"
];

tower(6) ==> [
  "     *     ", 
  "    ***    ", 
  "   *****   ", 
  "  *******  ", 
  " ********* ", 
  "***********"
];
```

## Посчитать смайлики
#### Условие:
Напишите функцию, которая принимает массив в качестве аргумента и должна вернуть общее количество улыбающихся смайликов.

#### Правила:
- На каждом смайлике должна быть изображена пара глаз. Глаза можно пометить как : или ;
- У смайлика может быть нос, но это необязательно. Допустимыми символами для обозначения носа являются - или ~
- На каждом улыбающемся лице должен быть изображен улыбающийся рот, который должен быть отмечен либо ), либо D
- Никаких символов, кроме указаных выше, быть не должно.
- Если массив пустой - нужно вернуть 0.
- Порядок элементов (глаза, нос и рот) считать всегда корректным.

#### Пример:
```
countSmileys([':)', ';(', ';}', ':-D']) ==> 2;
countSmileys([';D', ':-(', ':-)', ';~)']) ==> 3;
countSmileys([';]', ':[', ';*', ':$', ';-D']) ==> 1;
```

## Разложить camelCase
#### Условие:
Напишите функцию, которая разбивает camelCase, используя пробел между словами.

#### Пример:
```
camelToSpace('camelCasing') => 'camel Casing';
camelToSpace('identifier') => 'identifier';
camelToSpace("") => "";
```

## Проверка на простоту
#### Условие:
Напишите функцию, которая принимает целое число и возвращает ```true``` или ```false``` в зависимости от того, является ли целое число простым.

#### Правила:
- Вы можете считать, что на вход всегда приходит целое число.
- Вы не можете считать, что целое число будет только положительным. Вам также могут быть заданы отрицательные числа (или 0).
- Вы должны брать во внимание производительность.

#### Пример:
```
is_prime(1) ==> false;
is_prime(2) ==> true;
is_prime(-1) ==> false;
```

## Убрать все гласные
#### Условие:
Напишите функцию, которая принимает на вход строку и возвращает строку без гласных букв.

#### Правила:
- В строке могут содержаться любые символы, однако убрать нужно только гласные буквы.
- Буквы в строке будут взяты только из английского алфавита.

#### Пример:
```
removeVowels('Hello World!') ==> 'Hll Wrld!';
removeVowels('') ==> '';
```

## Все цифры в квадрат
#### Условие:
Напишите функцию, которая принимает на вход число, возводит каждую его цифру в квадрат и возвращает конкатенированное значение.

#### Правила:
- На вход могут прийти только целые числа.

#### Пример:
```
valueTransform(9119) ==> 811181;
valueTransform(765) ==> 493625;
```

## Порядок убывания
#### Условие:
Напишите функцию, которая принимает целое число в качестве аргумента и возвращать его с цифрами в порядке убывания.

#### Правила:
- На вход могут прийти только целые неотрицательные числа.

#### Пример:
```
numberDescend(42145) ==> 54421
numberDescend(145263) ==> 654321;
numberDescend(123456789) ==> 987654321;
```

## Создать наибольшее число
#### Условие:
Напишите функцию, которая принимает массив и расположит числа из него так, что получится наибольшее.

#### Правила:
- Массив содержит только целые неотрицательные числа.

#### Пример:
```
createMaxNumber([1, 2, 3]) ==> 321
createMaxNumber([3, 30, 34, 5, 9]) ==> 9534330;
numberDescend(123456789) ==> 987654321;
```

## 2048
#### Условие:
Напишите функцию, которая принимает массив проводит сложение аналогично игре 2048, имитируя движение справа налево.

#### Правила:
- Массив содержит только целые неотрицательные числа.
- Каждая ячейка может объединяться только один раз.
- Пустые квадраты сетки представлены в виде нулей.
- Ваша функция должна работать с массивами, содержащими произвольное количество элементов.

#### Пример:
```
merge([2, 0, 2, 2]) ==> [4, 2, 0, 0];

merge([4, 4, 8, 16]) ==> [8, 8, 16, 0];
merge([8, 8, 16, 0]) ==> [16, 16, 0, 0];
merge([16, 16, 0, 0]) ==> [32, 0, 0, 0];
```

## Центральный элемент
#### Условие:
Напишите функцию, которая принимает строку и возвращает символ из её центра.

#### Правила:
- Если в строке чётное количество символов, то возвращать 2 центральных.
- Строка не может быть пустой.

#### Пример:
```
findCentral('test') ==> 'es';
findCentral('testing') ==> 'testing';
findCentral('middle') ==> 'dd';
findCentral('A') ==> 'A';
```

## Маска
#### Условие:
Напишите функцию, которая принимает строку и заменяет все её символы, кроме 4х последних, в '#'.

#### Пример:
```
maskify('4556364607935616') ==> '############5616';
maskify('64607935616') ==> '#######5616';
maskify('1') ==> '1';
maskify('') ==> '';
```

## Сумма двух наименьших
#### Условие:
Напишите функцию, которая принимает массив целочисленных неотрицательных значений и возвращает сумму двух наименьших.

#### Правила:
- Во входном массиве гарантировано есть 4 числа.
- Массив не может содержать других типов данных.

#### Пример:
```
sumOfTwoLowest([19, 5, 42, 2, 77]) ==> 7;
sumOfTwoLowest([10, 343445353, 3453445, 3453545353453]) ==> 3453455;
```

## Найти все буквы
#### Условие:
Напишите функцию, которая принимает две строки и возвращает отсортированную строку (a -> z),
содержащую уникальные буквы, каждая из которых берётся только один раз из s1 или s2.

#### Правила:
- Вы можете считать, что буквы в строках всегда находятся в нижнем регистре.

#### Пример:
```
const a = 'xyaabbbccccdefww';
const b = 'xxxxyyyyabklmopq';
longest(a, b) ==> 'abcdefklmopqwxy';

const c = 'abcdefghijklmnopqrstuvwxyz';
longest(c, c) ==> 'abcdefghijklmnopqrstuvwxyz';
```

## Азбука Морзе
#### Условие:
Напишите функцию, которая принимает строку с кодом Морзе и возвращает расшифрованную версию.

#### Правила:
- Вы можете быть уверены, что во входной строке будут зашифрованы только буквы.

#### Подсказка:
 Сигнал| Буква | Сигнал| Буква 
:-----:|:-----:|:-----:|:-----:|
  .-   | A     |  -.   | N
  -... | B     |  ---  | O
  -.-. | C     |  .--. | P
  -..  | D     |  --.- | Q
  .    | E     |  .-.  | R
  ..-. | F     |  ...  | S
  --.  | G     |  -    | T
  .... | H     |  ..-  | U
  ..   | I     |  ...- | V
  .--- | J     |  .--  | W
  -.-  | K     |  -..- | X
  .-.. | L     |  -.-- | Y
  --   | M     |  --.. | Z

#### Пример:
```
decodeMorse('.... . -.--   .--- ..- -.. .') ==> 'HEY DUDE';
```

## Проверить конец строки
#### Условие:
Напишите функцию, которая принимает две строки и возвращает ```true```, если вторая строка находится в конце первой.

#### Правила:
- Если вторая строка = '', то функция должна вернуть ```true```.

#### Пример:
```
solution('abc', 'bc') ==> true;
solution('abc', 'd') ==> false;
```

## Бинарная сумма
#### Условие:
Напишите функцию, которая принимает два числа и возвращает их бинарную сумму.

#### Пример:
```
binarySum(1, 1) ==> 10;
binarySum(5, 9) ==> 1110;
```

## Глубокое клонирование
#### Условие:
Напишите функцию, которая принимает в себя объект и возвращает его полную копию.

#### Пример:
```
deepClone({ a: { b: 1 } }) ==> { a: { b: 1 } };
```

## flat для объектов
#### Условие:
Напишите функцию, которая превращает объект с вложенными полями в плоский объект с ключами через точку ```(a.b.c)```.

#### Пример:
```
flattenObject({ a: { b: { c: 1 } } }) ==> { 'a.b.c': 1 };
```

## UNflat для объектов
#### Условие:
Напишите функцию, которая выполняет обратную операцию к предыдущей — превращает объект с ключами в виде ```a.b.c``` обратно в вложенную структуру.

#### Пример:
```
unflattenObject({ 'a.b.c': 1 }) ==> { a: { b: { c: 1 } } };
```

## Найти разницу между объектами
#### Условие:
Напишите функцию, которая сравнивает два объекта и возвращает разницу между ними.

#### Пример:
```
diffObjects({ a: 1, b: 2 }, { a: 1, b: 3 }) ==> { b: { old: 2, new: 3 } };
```

## Проверить объект на пустоту
#### Условие:
Напишите функцию, которая проверяет, является ли объект пустым.

#### Пример:
```
isEmptyObject({}) ==> true;
isEmptyObject({ a: 1 }) ==> false;
```

## Найти ключ по значению
#### Условие:
Напишите функцию, которая находит первый ключ, содержащий заданное значение.

#### Пример:
```
findKey({ a: 1, b: 2, c: 1 }, 1) ==> 'a';
```

## Объединить два объекта с приоритетом второго
#### Условие:
Напишите функцию, которая объединяет два объекта, причём значения второго имеют приоритет.

#### Пример:
```
mergeObjects({ a: 1, b: 2 }, { b: 3, c: 4 }) ==> { a: 1, b: 3, c: 4 };
```

## Реализовать аналог Object.fromEntries()
#### Условие:
Напишите функцию, которая превращает массив пар [ключ, значение] в объект.

#### Пример:
```
fromEntries([['a', 1], ['b', 2]]) ==> { a: 1, b: 2 };
```

## Удалить свойства объекта
#### Условие:
Напишите функцию, которая удаляет из объекта все поля со значениями ```null``` и ```undefined```.

#### Пример:
```
cleanObject({ a: 1, b: null, c: undefined }) ==> { a: 1 };
```

## Глубокое слияние объектов
#### Условие:
Напишите функцию, которая рекурсивно объединяет два объекта.

#### Пример:
```
deepMerge({ a: { b: 1 } }, { a: { c: 2 } }) ==> { a: { b: 1, c: 2 } };
```

## Найти путь до ключа
#### Условие:
Напишите функцию, которая находит путь (в виде массива ключей) до указанного ключа в глубоко вложенном объекте. Если ключа нет, вернуть ```null```.

#### Пример:
```
findKeyPath({ a: { b: { c: 42 } } }, 'c') ==> ['a', 'b', 'c'];
findKeyPath({ x: { y: { z: 99 } } }, 'a') ==> null;
```

## Сортировка объекта по ключам
#### Условие:
Напишите функцию, которая сортирует объект по ключам в алфавитном порядке.

#### Пример:
```
sortObjectKeys({ b: 2, a: 1, c: 3 }) ==> { a: 1, b: 2, c: 3 };
```

## Сортировка объекта по ключам
#### Условие:
Напишите функцию, которая сортирует объект по ключам в алфавитном порядке.

#### Пример:
```
sortObjectKeys({ b: 2, a: 1, c: 3 }) ==> { a: 1, b: 2, c: 3 };
```

## Сортировка строки по частоте появления элементов
#### Условие:
Напишите функцию для сортировки символов в строке по их частоте встречаемости.

#### Пример:
```
sortByFrequency('abaabc') ==> 'abc';
```

## Сон
#### Условие:
Напишите функцию, которая останавливает выполнение кода на определенное время.

#### Пример:
```
console.log('start');
await sleep(2000);
console.log('2 seconds passed');
```

## Реализовать собственный filter
#### Условие:
Напишите функцию (или полифил), которая реализует всю логику нативного Array.prototype.filter.

## Реализовать бинарную сортировку
#### Условие:
Напишите функцию, которая, используя бинарный подход, сортирует входной массив.

## Счётчик
#### Условие:
Напишите функцию, которая, используя замыкание, будет увеличивать внутренний счётчик на 1 при каждом вызове.

#### Правила:
- Нельзя использовать var и внешние переменные.

#### Пример:
```
increment() ==> 1;
increment() ==> 2;
increment() ==> 3;
```

## Сумма всех чисел в объекте
#### Условие:
Напишите функцию, которая находит сумму всех целых чисел внутри объекта.

#### Пример:
```
const obj = { a: 1, b: { c: 2, d: { e: 3 }, f: 5.5 } };
sumNested(obj) ==> 6
```

## Найти максимальную глубину
#### Условие:
Напишите функцию, которая максимальную глубину вложенности у объекта.

#### Пример:
```
const obj = { a: { b: { c: { d: 5 } } } };
maxDepth(obj) ==> 4
```

## Поиск ближайшего числа в массиве
#### Условие:
Напишите функцию, которая принимает на вход массив целых чисел и аргумент (целое число), возвращая позицию и значение ближайшего к аргументу числа.

#### Пример:
```
closestNumber([1, 2, 4, 5], 3) ==> 'pos: 1, val: 2';
```

## Только один раз
#### Условие:
Напишите функцию, которая принимает функцию и даёт выполнить её только один раз.

#### Пример:
```
const initialize = once(() => console.log('Init!'));
initialize() ==> 'Init!';
initialize() ==> should do nothing;
```

## Длина аргументов
#### Условие:
Напишите функцию, которая возвращает количество переданных ей аргументов.

#### Пример:
```
argumentsLength(1, 2, 3) ==> 3;
```

## Сумма двух Promise
#### Условие:
Напишите функцию, которая принимает в себя два promise (каждый из которых возвращает число)
и возвращает promise, который должен выполнить resolve, вернув их сумму значений.

#### Пример:
```
addTwoPromises(Promise.resolve(2), Promise.resolve(2))
  .then(console.log) ==> 4;
```